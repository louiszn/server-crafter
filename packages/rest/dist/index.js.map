{"version":3,"sources":["../src/enums.ts","../src/REST.ts"],"sourcesContent":["export enum APIRoutePrefix {\n\tUsers = \"/users\",\n\tAuth = \"/auth\",\n}\n\nexport enum APIUsersRoute {\n\tGetAll = \"/\",\n\tGetById = `/:userId`,\n\tCurrent = `/@me`,\n}\n\nexport enum APICurrentUserRoute {\n\tGet = `/`,\n\tModify = `/`,\n}\n\nexport enum APIAuthRoute {\n\tCreate = \"/create\",\n\tLogin = \"/login\",\n\tRefreshToken = \"/refresh\",\n\tLogout = \"/logout\",\n}\n\nexport enum APIRoute {\n\tGetUserById = `${APIRoutePrefix.Users}${APIUsersRoute.GetById}`,\n\tGetAllUsers = `${APIRoutePrefix.Users}${APIUsersRoute.GetAll}`,\n\tGetCurrentUser = `${APIRoutePrefix.Users}${APIUsersRoute.Current}${APICurrentUserRoute.Get}`,\n\tModifyCurrentUser = `${APIRoutePrefix.Users}${APIUsersRoute.Current}${APICurrentUserRoute.Modify}`,\n\n\tCreateUser = `${APIRoutePrefix.Auth}${APIAuthRoute.Create}`,\n\tLogin = `${APIRoutePrefix.Auth}${APIAuthRoute.Login}`,\n\tRefreshToken = `${APIRoutePrefix.Auth}${APIAuthRoute.RefreshToken}`,\n\tLogout = `${APIRoutePrefix.Auth}${APIAuthRoute.Logout}`,\n}\n","import type { ZodIssue } from \"zod/v3\";\nimport type { APIRefreshTokenResponse } from \"./types/auth\";\nimport { APIRoute } from \"./enums\";\n\ntype FindParam<T extends string> = T extends `:${infer P}` ? P : never;\n\ntype SplitBySlash<T extends string> = T extends `${infer First}/${infer Rest}`\n\t? First | SplitBySlash<Rest>\n\t: T;\n\ntype ExtractPathParams<T extends string> = FindParam<SplitBySlash<T>>;\n\ntype HasParams<T extends APIRoute> = ExtractPathParams<T> extends never ? false : true;\n\nexport type Params<T extends APIRoute> = {\n\t[K in ExtractPathParams<T>]: string;\n};\n\nexport enum RequestMethod {\n\tGet = \"GET\",\n\tDelete = \"DELETE\",\n\tPatch = \"PATCH\",\n\tPost = \"POST\",\n\tPut = \"PUT\",\n}\n\nexport interface ResponseError {\n\tcode: number;\n\terror: string | ZodIssue[];\n}\n\nexport type RESTRequestInit = Omit<RequestInit, \"method\" | \"body\">;\n\nexport abstract class REST {\n\tpublic static baseUrl: string = process.env.NEXT_PUBLIC_API_URL!;\n\n\tpublic static get<T>(endpoint: string, init?: RESTRequestInit) {\n\t\treturn this.request<T>(RequestMethod.Get, endpoint, undefined, init);\n\t}\n\n\tpublic static post<T, P>(endpoint: string, payload: P, init?: RESTRequestInit) {\n\t\treturn this.request<T, P>(RequestMethod.Post, endpoint, payload, init);\n\t}\n\n\tpublic static put<T, P>(endpoint: string, payload: P, init?: RESTRequestInit) {\n\t\treturn this.request<T, P>(RequestMethod.Put, endpoint, payload, init);\n\t}\n\n\tpublic static patch<T, P>(endpoint: string, payload: P, init?: RESTRequestInit) {\n\t\treturn this.request<T, P>(RequestMethod.Patch, endpoint, payload, init);\n\t}\n\n\tpublic static delete<T>(endpoint: string, init?: RESTRequestInit) {\n\t\treturn this.request<T>(RequestMethod.Delete, endpoint, undefined, init);\n\t}\n\n\tpublic static async request<T, P = unknown>(\n\t\tmethod: RequestMethod,\n\t\tendpoint: string,\n\t\tpayload?: P,\n\t\tinit?: RESTRequestInit,\n\t): Promise<[T, null] | [null, ResponseError]> {\n\t\tconst response = await this.makeRequest<T, P>(method, endpoint, payload, init);\n\n\t\tconst [, error] = response;\n\n\t\tif (error && error.code === 401 && this.getAccessToken()) {\n\t\t\tconst isRefreshed = await this.refreshToken();\n\n\t\t\tif (isRefreshed) {\n\t\t\t\t// We got the new access token, everything should be fine now\n\t\t\t\treturn await this.makeRequest<T, P>(method, endpoint, payload, init);\n\t\t\t}\n\t\t}\n\n\t\treturn response;\n\t}\n\n\tpublic static async makeRequest<T, P = unknown>(\n\t\tmethod: RequestMethod,\n\t\tendpoint: string,\n\t\tpayload?: P,\n\t\tinit?: RESTRequestInit,\n\t): Promise<[T, null] | [null, ResponseError]> {\n\t\tconst headers = new Headers(init?.headers);\n\n\t\theaders.set(\"Content-Type\", \"application/json\");\n\n\t\tconst accessToken = this.getAccessToken();\n\n\t\tif (accessToken) {\n\t\t\theaders.set(\"Authorization\", `Bearer ${accessToken}`);\n\t\t}\n\n\t\ttry {\n\t\t\tconst url = new URL(endpoint, this.baseUrl).toString();\n\n\t\t\tconst response = await fetch(url, {\n\t\t\t\t...init,\n\t\t\t\tmethod,\n\t\t\t\theaders,\n\t\t\t\tbody: JSON.stringify(payload),\n\t\t\t});\n\n\t\t\tconst json = await this.getJSONResponse<P>(response);\n\n\t\t\tif (!response.ok) {\n\t\t\t\treturn [null, json as ResponseError];\n\t\t\t}\n\n\t\t\treturn [json as T, null];\n\t\t} catch (error) {\n\t\t\treturn [\n\t\t\t\tnull,\n\t\t\t\t{\n\t\t\t\t\tcode: 0,\n\t\t\t\t\terror: error instanceof Error ? error.message : \"Unknown error\",\n\t\t\t\t},\n\t\t\t];\n\t\t}\n\t}\n\n\tprivate static async refreshToken(): Promise<boolean> {\n\t\tconst [data, error] = await this.makeRequest<APIRefreshTokenResponse>(\n\t\t\tRequestMethod.Post,\n\t\t\tAPIRoute.RefreshToken,\n\t\t\t{},\n\t\t\t{\n\t\t\t\t// Refresh token is included as cookie\n\t\t\t\tcredentials: \"include\",\n\t\t\t},\n\t\t);\n\n\t\tif (error) {\n\t\t\tthis.removeAccessToken();\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.setAccessToken(data.accessToken);\n\n\t\treturn true;\n\t}\n\n\tpublic static useRoute<T extends APIRoute>(\n\t\tendpoint: T,\n\t\t...args: HasParams<T> extends false ? [] : [params: Params<T>] // Make params optional if there are no params\n\t): string;\n\tpublic static useRoute<T extends APIRoute>(endpoint: T, params: Params<T>): string;\n\tpublic static useRoute<T extends APIRoute>(endpoint: T, params?: Params<T>): string {\n\t\tlet result: string = endpoint;\n\n\t\tif (typeof params == \"object\") {\n\t\t\tfor (const k in params) {\n\t\t\t\tresult = result.replace(`:${k}`, params[k as keyof Params<T>]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic static getAccessToken() {\n\t\treturn sessionStorage.getItem(\"accessToken\") || localStorage.getItem(\"accessToken\") || null;\n\t}\n\n\tpublic static removeAccessToken() {\n\t\tsessionStorage.removeItem(\"accessToken\");\n\t\tlocalStorage.removeItem(\"accessToken\");\n\t}\n\n\tpublic static setAccessToken(token: string, remember = false) {\n\t\treturn (remember ? localStorage : sessionStorage).setItem(\"accessToken\", token);\n\t}\n\n\tprivate static async getJSONResponse<T>(response: Response): Promise<T | ResponseError | object> {\n\t\tconst contentType = response.headers.get(\"content-type\");\n\n\t\tif (response.status === 201 || response.status === 204) {\n\t\t\treturn {};\n\t\t}\n\n\t\tif (contentType?.startsWith(\"application/json\")) {\n\t\t\tconst data = await response.json();\n\n\t\t\tif (!response.ok) {\n\t\t\t\treturn {\n\t\t\t\t\tcode: response.status,\n\t\t\t\t\t...data,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\treturn {\n\t\t\tcode: response.status,\n\t\t\terror: response.statusText,\n\t\t};\n\t}\n}"],"mappings":"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","names":["APIRoutePrefix","APIUsersRoute","APICurrentUserRoute","APIAuthRoute","APIRoute","RequestMethod"]}